---
title: 'Islands Architecture'
description: 'Descubra a Arquitetura de Ilhas, um padrão que favorece a entrega de HTML estático com "ilhas" de interatividade, melhorando drasticamente a performance e o Time to Interactive (TTI).'
icon: 'component'
category: 'Arquiteturas de Aplicação'
---

Se a SPA é um extremo (tudo no cliente) e o MPA/SSR tradicional é outro (tudo no servidor), a Arquitetura de Ilhas é o meio-termo genial que o mundo front-end precisava. A ideia, popularizada pelo Astro, é incrivelmente simples e poderosa: por padrão, envie HTML puro, sem JavaScript. E então, para cada componente que *precisa* de interatividade, crie uma "ilha" isolada de JavaScript.

Frameworks como o Astro são os campeões dessa abordagem. Eles te dão o poder de componentes do React, Svelte, etc., mas com a performance de um site estático como padrão. É o melhor dos dois mundos, e a prova de que nem toda aplicação precisa ser uma SPA complexa.

### O que é?

## O Problema que Resolve

Aplicações de página única (SPAs) tradicionalmente enviam um grande bundle de JavaScript para o navegador. O browser então precisa baixar, analisar e executar todo esse código para poder renderizar a página e torná-la interativa. Isso pode levar a um Time to Interactive (TTI) alto, prejudicando a performance percebida pelo usuário, especialmente em dispositivos móveis ou com conexões lentas.

## Como Funciona

A Arquitetura de Ilhas (Islands Architecture) propõe uma abordagem diferente. Em vez de uma única "ilha" grande de aplicação (a SPA), a página é renderizada no servidor como HTML estático e leve, e pequenas "ilhas" de interatividade são "hidratadas" no lado do cliente conforme necessário.

O conceito principal é:

1.  **Renderização no Servidor (SSR/SSG)**: A maior parte do site é HTML estático, gerado no momento do build (SSG) ou sob demanda (SSR). Isso torna o carregamento inicial extremamente rápido.
2.  **Ilhas de Interatividade**: Componentes que precisam de JavaScript para funcionar (como um carrossel de imagens, um formulário com validação em tempo real ou um botão de "adicionar ao carrinho") são identificados como "ilhas".
3.  **Hidratação Seletiva**: Apenas o código JavaScript dessas ilhas é enviado para o navegador. A "hidratação" (o processo de tornar o HTML estático interativo) acontece de forma independente para cada ilha. Frameworks como o **Astro** (que você está usando neste projeto) são pioneiros nessa abordagem e oferecem diretivas para controlar quando uma ilha deve ser hidratada (ex: `client:load`, `client:idle`, `client:visible`).

## Diagrama de Fluxo

```mermaid
graph TD
    subgraph "Servidor (Build Time / Request Time)"
        A[HTML Estático da Página]
    end

    subgraph "Cliente (Browser)"
        B(Carregamento Rápido do HTML)
        C{Ilha Interativa 1 <br/> (ex: Carrossel)}
        D{Ilha Interativa 2 <br/> (ex: Busca)}
        E[JavaScript da Ilha 1]
        F[JavaScript da Ilha 2]
    end

    A --> B;
    B --> C;
    B --> D;
    C -- Hidratação --> E;
    D -- Hidratação --> F;

    style A fill:#f9f,stroke:#333,stroke-width:2px
    style B fill:#ccf,stroke:#333,stroke-width:2px

```

## Benefícios

-   **Performance Superior**: Reduz drasticamente a quantidade de JavaScript enviada ao cliente, resultando em um TTI muito mais rápido.
-   **SEO Aprimorado**: O conteúdo é renderizado no servidor, facilitando a indexação por motores de busca.
-   **Resiliência**: Se o JavaScript de uma ilha falhar, ele não quebra o resto da página.
-   **Agnóstico a Framework**: Você pode ter ilhas escritas em diferentes frameworks (React, Svelte, Vue) na mesma página.

## TL;DR

-   **HTML primeiro**: Envia HTML estático e leve para o navegador.
-   **Hidratação seletiva**: Apenas os componentes interativos ("ilhas") carregam JavaScript.
-   **Performance por padrão**: O objetivo principal é minimizar o JavaScript no cliente.
-   **Ideal para sites de conteúdo**: Perfeito para blogs, e-commerce e sites de marketing, mas flexível o suficiente para aplicações mais complexas.

## Referências

- **[Islands Architecture by Jason Miller](https://jasonformat.com/islands-architecture/)** - O post original que popularizou o termo.
- **[Astro Docs: Island Architecture](https://docs.astro.build/en/concepts/islands/)** - A documentação do Astro, que é um dos principais frameworks a adotar o padrão.

---

### Análise Arquitetural

#### Quando Usar?
*   **Sites Focados em Conteúdo com Ilhas de Interatividade:** O caso de uso perfeito. Blogs, sites de notícias, e-commerce, portais de documentação (como este!).
*   **Prioridade Máxima em Performance de Carregamento:** Para métricas como First Contentful Paint (FCP) e Time to Interactive (TTI), essa arquitetura é imbatível, pois envia o mínimo de JavaScript possível por padrão.
*   **Projetos com SEO Crítico:** O conteúdo é renderizado no servidor (SSR/SSG), tornando-o perfeitamente indexável por buscadores.

#### Trade-offs (Contras)
*   **Complexidade de Estado Global:** Compartilhar estado entre diferentes ilhas não é trivial e pode exigir soluções customizadas ou o uso de stores que rodam fora das ilhas.
*   **Não Ideal para "Apps":** Em aplicações altamente interativas (como um editor de fotos, um dashboard complexo ou o Gmail), onde quase toda a tela é uma "ilha", o modelo perde suas vantagens e um SPA tradicional pode ser mais simples.
*   **Mudança de Paradigma:** Exige que os desenvolvedores pensem cuidadosamente sobre o que precisa ser interativo e o que pode ser HTML estático, uma mentalidade diferente da abordagem "tudo é JavaScript" de um SPA.

---

### Exemplos no Mundo Real

*   **Aplicações Famosas:**
    *   **eBay:** Um dos primeiros grandes players a discutir publicamente sua implementação de uma arquitetura semelhante (conhecida como "top-down hydration").
    *   **Qualquer site construído com Astro:** Por padrão, o Astro segue a arquitetura de ilhas.

*   **Stacks de Tecnologia Comuns:**
    *   **Frameworks:** Astro, Qwik, Fresh (para Deno), Eleventy (com ilhas via plugin).
    *   Você pode usar qualquer framework de UI (React, Svelte, Vue) para criar os componentes que serão as "ilhas" dentro desses frameworks.

*   **Repositórios de Exemplo / Boilerplates:**
    *   **[Astro Starter Kits](https://astro.build/themes/)**
    *   **[Qwik City Starter](https://qwik.builder.io/docs/getting-started/)**
    *   **[Fresh Starter Template](https://fresh.deno.dev/)**

---

### Como Começar

Adotar a arquitetura de Ilhas é mais sobre escolher o framework certo do que configurar algo complexo do zero.

1.  **Com Astro:**
    Qualquer componente de UI (React, Svelte, Vue, etc.) pode se tornar uma ilha. O segredo é a diretiva `client:*`.

    *   **Crie seu componente interativo:**
        ```jsx
        // src/components/Counter.jsx
        import { useState } from 'react';

        export default function Counter() {
          const [count, setCount] = useState(0);
          return (
            <div className="border p-4">
              <p>Contador: {count}</p>
              <button onClick={() => setCount(count + 1)} className="bg-blue-500 text-white p-2">
                Incrementar
              </button>
            </div>
          );
        }
        ```

    *   **Use-o em uma página Astro com uma diretiva `client:`:**
        ```astro
        ---
        // src/pages/index.astro
        import Layout from '../layouts/Layout.astro';
        import Counter from '../components/Counter.jsx';
        ---
        <Layout title="Ilhas com Astro">
          <h1>Página Estática com Ilha Interativa</h1>
          <p>Este conteúdo é estático e não carrega JavaScript.</p>

          {/* Esta é a ilha. O JS só será carregado quando o componente for visível. */}
          <Counter client:visible />
        </Layout>
        ```
        A diretiva `client:visible` instrui o Astro a hidratar o componente apenas quando ele entra na tela, economizando recursos.

2.  **Com Fresh (Deno):**
    Fresh tem uma convenção de arquivos para ilhas.

    *   **Crie seu componente na pasta `islands/`:**
        Qualquer arquivo em `islands/` é tratado como uma ilha.
        ```tsx
        // islands/Countdown.tsx
        import { useState, useEffect } from 'preact/hooks';

        export default function Countdown() {
          const [time, setTime] = useState(10);

          useEffect(() => {
            const timer = setInterval(() => {
              setTime(t => t > 0 ? t - 1 : 0);
            }, 1000);
            return () => clearInterval(timer);
          }, []);

          return (
            <div>
              <p>Contagem regressiva: <strong>{time}</strong></p>
            </div>
          );
        }
        ```
    *   **Use-o em uma rota:**
        Apenas importe e use. O Fresh cuida da hidratação automaticamente.
        ```tsx
        // routes/index.tsx
        import Countdown from '../islands/Countdown.tsx';

        export default function Home() {
          return (
            <div>
              <h2>Página gerada no servidor</h2>
              <p>Abaixo está um componente interativo:</p>
              <Countdown />
            </div>
          );
        }
        ```
