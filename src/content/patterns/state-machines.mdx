---
title: 'State Machines (Máquinas de Estado)'
description: 'Aprenda a usar Máquinas de Estado Finitas para gerenciar estados complexos na UI, eliminando bugs de estados impossíveis e tornando a lógica de componentes mais previsível e robusta.'
icon: 'workflow'
category: 'Arquitetura'
layout: '../../layouts/ContentLayout.astro'
---

Se você já se viu escrevendo um componente React com uma teia de `useState` e `useEffect` para controlar o que é exibido na tela (`isLoading`, `isError`, `isSuccess`, `isSubmitting`...), você sabe a dor que as máquinas de estado resolvem.

Máquinas de Estado são a resposta para esse caos. Em vez de um monte de `boolean`s espalhados, você define de forma explícita todos os estados possíveis que sua UI pode ter (`loading`, `success`, `error`, etc.) e as transições permitidas entre eles. Um componente *não pode* estar em dois estados ao mesmo tempo.

Para mim, adotar máquinas de estado (especialmente com bibliotecas como XState) foi um divisor de águas na criação de componentes complexos. O código fica mais previsível, mais fácil de testar e, honestamente, mais fácil de entender meses depois. É a ferramenta certa para domar a complexidade do estado da UI.

### O que são?

Uma Máquina de Estado Finito (Finite State Machine - FSM) é um modelo que formaliza esse gerenciamento. Ela define que um sistema só pode estar em **um único estado** por vez, e que as transições entre os estados são explícitas e controladas.

Os conceitos principais são:

1.  **Estados (States)**: Um conjunto finito de todos os possíveis estados em que o componente pode estar (ex: `idle`, `loading`, `success`, `error`).
2.  **Eventos (Events)**: Ações que podem acionar uma mudança de estado (ex: `SUBMIT`, `RESOLVE`, `REJECT`).
3.  **Transições (Transitions)**: Regras que determinam para qual estado a máquina deve ir, dado o estado atual e um evento. Por exemplo: "No estado `loading`, ao receber o evento `REJECT`, vá para o estado `error`".

Bibliotecas como a **XState** popularizaram o uso de máquinas de estado no front-end, fornecendo ferramentas para criar, visualizar e executar máquinas de estado de forma declarativa.

## Benefícios

-   **Previsibilidade**: Elimina "estados impossíveis", tornando o comportamento da UI completamente previsível.
-   **Visualização**: Máquinas de estado podem ser visualizadas como diagramas, o que facilita o entendimento, a depuração e a comunicação entre desenvolvedores e designers.
-   **Testabilidade**: Cada estado e transição pode ser testado de forma isolada e determinística.
-   **Código Declarativo**: O código descreve "o que" a lógica deve fazer, não "como" ela deve fazer, resultando em um código mais limpo e fácil de manter.

## Quando Evitar

-   **Componentes Simples**: Para componentes com pouca ou nenhuma lógica de estado (como um botão puramente visual ou um título), usar uma máquina de estado é um exagero.
-   **Curva de Aprendizagem**: Embora o conceito seja simples, a implementação com bibliotecas como a XState pode ter uma curva de aprendizado para equipes que não estão familiarizadas.

## TL;DR

-   **Um estado por vez**: Evita estados impossíveis e inconsistentes na UI.
-   **Transições explícitas**: As mudanças de estado são controladas e previsíveis.
-   **Visualize sua lógica**: Ferramentas como o XState permitem criar diagramas da lógica do seu componente.
-   **Ideal para complexidade**: Brilha em componentes com muitos estados e transições, como formulários, fluxos de checkout ou players de vídeo.

## Referências

- **[XState Docs](https://xstate.js.org/docs/)** - A documentação oficial da biblioteca mais popular para máquinas de estado em JavaScript.
- **[Statecharts: The Next Level of State Management](https://www.youtube.com/watch?v=NdBq4NvoQe4)** - Uma palestra clássica que explica os benefícios de usar statecharts (uma evolução das FSMs).

---

### Análise Arquitetural

#### Quando Usar?
*   **Fluxos de Usuário Complexos:** Qualquer componente que tenha mais do que alguns poucos estados (ex: `loading`, `success`, `error`) pode se beneficiar. Exemplos: formulários com múltiplos passos, upload de arquivos, players de vídeo.
*   **Para Prevenir Estados Impossíveis:** É a grande vantagem. Uma máquina de estados garante que sua UI nunca chegue a um estado que não deveria existir (ex: estar em `success` e `error` ao mesmo tempo).
*   **Lógica de Orquestração:** Quando uma ação do usuário precisa disparar uma série de eventos ou transições de forma previsível.

#### Trade-offs (Contras)
*   **Curva de Aprendizagem:** Pensar em termos de estados e transições é diferente de usar `if/else` e `boolean` flags. Exige uma mudança de mentalidade.
*   **Verboso para Casos Simples:** Para um componente com apenas dois estados (ex: um toggle), usar uma máquina de estados formal (com uma biblioteca como XState) é um exagero.
*   **Integração com Frameworks:** Embora bibliotecas como XState tenham integrações para React, Vue, etc., ainda é uma camada extra de abstração para gerenciar no seu código.

---

### Exemplos no Mundo Real

*   **Casos de Uso Comuns:**
    *   **Players de Vídeo:** Gerenciar os estados `playing`, `paused`, `buffering`, `ended`, `error`.
    *   **Formulários Complexos:** Gerenciar os estados de cada campo, validações e o estado geral do envio (`idle`, `submitting`, `success`, `error`).
    *   **Fluxos de Autenticação:** Orquestrar os múltiplos passos de um login com MFA (Multi-Factor Authentication).
    *   **Qualquer componente com mais de 3 ou 4 estados booleanos (`isLoading`, `isError`, `isDisabled`...) é um candidato.**

*   **Bibliotecas Populares:**
    *   **XState:** A biblioteca mais poderosa e completa, que implementa a especificação SCXML (State Chart XML).
    *   **Zustand:** Embora seja um gerenciador de estado geral, sua API pode ser usada para criar máquinas de estado simples.
    *   **Redux Toolkit:** Seu `createSlice` pode ser usado para modelar uma máquina de estados finitos.

*   **Repositórios de Exemplo / Boilerplates:**
    *   **[XState Visualizer](https://stately.ai/viz)** - Uma ferramenta para visualizar e interagir com máquinas de estado XState.
    *   **[Jogo em React com XState](https://github.com/cassiozen/tic-tac-toe-xstate)** - Exemplo de um jogo da velha usando React e XState.

---

### Como Começar

A maneira mais robusta de usar máquinas de estado no front-end é com a biblioteca XState.

1.  **Instale o XState e seu adaptador para seu framework:**

    ```bash
    # Core do XState e o hook para React
    pnpm add xstate @xstate/react
    ```

2.  **Crie sua primeira máquina:**
    Vamos modelar uma busca de dados, um caso de uso muito comum.

    ```javascript
    // src/machines/fetchMachine.js
    import { createMachine, assign } from 'xstate';

    // A função que realmente busca os dados
    const fetchData = () => fetch('https://api.exemplo.com/data').then(res => res.json());

    export const fetchMachine = createMachine({
      id: 'fetch',
      initial: 'idle',
      // 'context' é o estado estendido (os dados) da sua máquina
      context: {
        data: null,
        error: null,
      },
      states: {
        idle: {
          on: { FETCH: 'loading' }, // Transição: do estado 'idle' para 'loading' no evento 'FETCH'
        },
        loading: {
          invoke: {
            src: fetchData, // Invoca a função de busca
            onDone: {
              target: 'success',
              actions: assign({ data: (context, event) => event.data }), // Salva os dados no contexto
            },
            onError: {
              target: 'failure',
              actions: assign({ error: (context, event) => event.data }), // Salva o erro no contexto
            },
          },
        },
        success: {
          type: 'final', // É um estado final
        },
        failure: {
          on: { RETRY: 'loading' }, // Pode tentar novamente no evento 'RETRY'
        },
      },
    });
    ```

3.  **Use a máquina em um componente React:**
    O hook `useMachine` permite que seu componente reaja às mudanças de estado.

    ```jsx
    // src/components/DataFetcher.jsx
    import React from 'react';
    import { useMachine } from '@xstate/react';
    import { fetchMachine } from '../machines/fetchMachine';

    function DataFetcher() {
      const [state, send] = useMachine(fetchMachine);

      return (
        <div>
          {state.matches('idle') && (
            <button onClick={() => send('FETCH')}>Buscar Dados</button>
          )}

          {state.matches('loading') && <p>Carregando...</p>}

          {state.matches('success') && (
            <div>
              <h2>Dados Carregados:</h2>
              <pre>{JSON.stringify(state.context.data, null, 2)}</pre>
            </div>
          )}

          {state.matches('failure') && (
            <div>
              <p>Erro: {state.context.error.message}</p>
              <button onClick={() => send('RETRY')}>Tentar Novamente</button>
            </div>
          )}
        </div>
      );
    }
    ```
    Note como a lógica de UI é declarativa e separada da lógica de estado. O componente apenas "pergunta" à máquina em qual estado ela está (`state.matches(...)`) e envia eventos (`send(...)`).
